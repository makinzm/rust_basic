
Ref:

- https://cheats.rs/
- https://doc.rust-jp.rs/book-ja/
- https://doc.rust-lang.org/book/
- https://docs.rs/
    - https://doc.rust-lang.org/std/vec/struct.Vec.html

- 次の動画を見る: https://www.youtube.com/watch?v=tw2WCjBTgRM
---


- hello_world: 
    - cargo new と cargo run
- variable: 
    - `let, let mut, println!("{}", a)`
    - let を大量に用意するとパフォーマンスが下がる場合がある.
    - `const` と `let` の違い
        - let: compileの段階で決まらなくても良い(再代入ができないだけ)
        - const: magic number などいれるとき
        - 型注釈: 簡単な場合は書く必要はない場合もある. (analyzerのおかげ,vscodeの拡張機能)
- シャドウィング: 
    - 同じ名前で複数宣言できる.(いつ使う?): letの場合
    - `{}`の blockで scopeなど寿命がある. 
    - block内で global変数と同じ名前を使っても良い.
- 静的:
    - compileした時に型がわかる必要がある.
    - 整数:
        - arch: CPUのarchitectureによって最も早いものが使われる
            - usize, isize
        - リテラル
            - あんすこ, 0x, 0o など 
    - 整数や少数の演算:
        - 同じ型である必要がある.
        - as で 変換する.
    - char:(Unicode)
        - 1文字
    - tuple:
        - 型の書き方も (型,型)
        - tuple に dot で 何番目の値を得る.
    - 配列:
        - stackにある , 長さ変えられない [,]
        - [型;個数]
        - 配列[番目]でアクセス
            - c,js,c++などに似ている
                - c++ではstd:: が推奨されているしね
            - rustはpanicとなる
- 関数
    - snake_case
    - 後に定義しても呼べる
    - 引数
        - 値をそのまま入れる場合は i32 や char でおけ
        - 所有権を与えて良いかどうかで判断.
    - 式と文について
- 制御文
    - if
        - 一つの場合は () で括らないようにする.
        - boolで必要である. (0以外はtrueなどはダメ)
        - elif ではなく　else if をつかう
        - if は 式である.
            - つまり,戻り値は同じである必要がある.
    - loop
        - loop
            - 無限ループ
            - 'name : loop{} で labelをつけられる.
        - while
        - for
            - in 0..5 : 0以上5未満
- 所有権
    - stack: 実行されているすぐ近くにある(少量)
    - heap: OSが管理するたくさんの領域
    - 所有者は一つ, 所有者が破棄されるとアタイも破棄される
    - string
        - &str : immutable
        - しかし,Stringは mutable
            - String::new() などある.
            - s = String::from("")
                - ""は&str
                - 文字列リテラルは3章になる.
            - push_strなど便利
            - s.push_str("");
            - Stringの結合は + があるけど, formatマクロ が望ましい
                - println と同じような者
                - Stringは Vec<u8>の Wrapper
                - lenなど はつかえるが 添字アクセスは どのbyte数などかなど
                - 文字列のスライスはあるけど, byteによってエラーの発生が発生しうる.
            - 文字列の場合は, charsが便利.
                - s.chars().nth(2);
        - capacityとlenについて
    - blockから抜ければ勝手にOSにheapの連絡をする.
    - move
        - 所有権の移動
        - bugの温床....
    - clone
        - 所有権とは別にheapを確保する.
    - 関数の引数
        - primitive型はstackにあるため, 消えない
    - 参照と借用
        - アンパッさんで借用すると,heap領域を指し示すやつを指し示すやつ(instack) を用意できる.
    - 可変な借用
        - 変えてるけど変更の可能性がある: &mut
        - 一つだけ可変な参照をもてる.
    - 普遍な借用
        - これは何個でも大丈夫.
    - dangling pointer
        - heapはあるけど, stackが消される.
        - これは良くないため compile error
        - 対策: 所有権を上げればよい
- スライス型
    - &a[1..3] など
    - 普遍な参照と可変な参照をとるとまずい
    - Stringは変わらないようになる.
    - &str と &String
- struct
    - 構造体: dataclass: 新しい型を用意できる.
    - fieldsを用意
    - Data {field_name: value, }
        - 名前と変数が同じの場合は省略できる.
        - {} なかで既に定義したものを展開できたりする.
    - fieldには . でアクセスできる
    - tuple-構造体
    - Derive-debug:
        - 全部を順番に表示してね.
        - {:?} を使うと良い.
    - impl で　構造体に関してのmethodを定義できる.
        - &self で instance method
            - . で呼べる
            - &mut self で可変な参照も取れる.
        - &self なしで class method
            - :: で呼べる.
    - Self: 自分自身の型を表す.
- Enum
    - :: で呼び出される
    - それぞれメンバ変数を用意できる.
        - structを用意すると楽
    - 同じ型として扱える.
    - struct同様にimplできる
    - Option
        - SomeかNoneをもつEnumでofficialで定義される.
    - matchについて
        - =>  とできる.
            - Some(number: i32) など書ける.
            - if let
                - Some側のカッコで, block内の変数を定義できる.
        - enumについて処理を全て書かないといけない.
        - これで,Evolution の 処理の忘れを防ぐことができる.
- File分割
    - module単位になる.
    - pub とつけると他のmoduleからも使える.
    - 引用側からは, 
    - pub mod module_name;
    - use module_name::func;
    - でできる.
    - directory構造の場合.
        - そのdirectoryと同じ名前のfileを作成してから,引用する.
- Collection
    - vector, hashMap など
        - Vec::new(), vec![] (マクロ)
            - &v で sliceを作成できる.
        - &v[2] で借用しながら値をもらえる.
            - ここは普遍な参照となる. (&mut v[0] などできる?)
        - .get の場合は Noneなのか　Someなのか意識できる.
        - for i &mut v {
        -   *i += 50; // i で 参照外しができる.   
        - }
    - String
    - HashMap
        - std::collections:HashMap
        - insert, entry, or_insert などができる.
        - HashMap::new()
        - get で 値を受け取ることができる(Optionが帰ってくる)
        - &でforを回せる(key,value)
        - 独自のhashも使えるね
    - btreeMap, btreeSet などたくさんある.
- エラー処理 
    - Panic処理 
        - RUST_BACKTRACE=1 cargo run とやると便利.
        - 比較的 最終手段
    - Result
        - Ok(file)
        - Err(ref error) if などで matchのrefなどがある
        - unwrap(); result を okだったり中身, errorの場合はpanicにできる.
        - 戻り値で Result を使うと便利.
        - Result を管理するのがめんどいため, ? 演算子を使うと便利であったりする.
            - ?は Resultを返すときだけ.
        - match処理をする.
        - 描いてる側は絶対良いとされるときは unwrapなどが良い.
    - panic or result
        - ガイドライン: https://doc.rust-jp.rs/book-ja/ch09-03-to-panic-or-not-to-panic.html#%E3%82%A8%E3%83%A9%E3%83%BC%E5%87%A6%E7%90%86%E3%81%AE%E3%82%AC%E3%82%A4%E3%83%89%E3%83%A9%E3%82%A4%E3%83%B3

- Generics, Trait, Lifetime
    - Generics
        - <T> と関数につければ良い.
            - ただ,Tが比較可能かわからない場合　だめ
            - trait の知識が必要.
        - 利用する際には <> の中身は埋める必要はない.
        - <U> <E> なども利用すると良い.
        - impl<T> STRUCT<T> というみなれなさ: 
            - ある型のみに impl できたりもする.
            - 一つ目は宣言で,  二つ目が使用されるみたいなもの
    - Trait
        - interface みたいなもの
        - implements ではなく : impl TRAIT for STRUCT のように使う.
        - <T: TRAIT> のようにできる(TRAITが実装される型 Tについて)
        - 型として　TRAIT は足し算で書ける.
        - whereで traitの条件を まとめたりできる
        - return で　impl Trait を書くのは難しい.
        - `+ Copy` で moveをなくして, copyするようにできる.
    - Lifetime
        - &'life_time_name で life_time を関数に教えられる.
            - たくさんある場合,短いものが採用される.
        - fn func<'life_time_name>
        - 関数と戻り値だけ指定した場合. 関数ないでしか生きられない.
        - 構造体で参照を持っている場合,も定義できる.
            - 構造体の中のfieldにあると panicになる.
        - genericsと併用する場合は, life_timeが先.
